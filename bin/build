#!/usr/bin/env ruby

# frozen_string_literal: true
require 'bundler/setup'
require 'json'
require 'commons/builder'
require 'rest-client'

URL = 'https://query.wikidata.org/sparql'

config = Config.new("config.json").values
LANGUAGE_MAP = config[:language_map]
COUNTRY_WIKIDATA_ID = config[:country_wikidata_id]

root_dir = Pathname.new('').dirname

valid_actions = %w[update build]

unknown_args = Set.new(ARGV) - Set.new(valid_actions)
unless unknown_args.empty?
  STDERR.puts "Usage: #{$PROGRAM_NAME} update|build"
  exit(1)
end

actions = if ARGV.empty?
            valid_actions.clone
          else
            ARGV.clone
          end

wikidata_labels = WikidataLabels.new(LANGUAGE_MAP)

boundaries_dir = Dir.exist?('boundaries/build') ? 'boundaries/build' : 'boundaries'
boundary_data = BoundaryData.new(wikidata_labels, boundaries_dir: boundaries_dir)

boundary_position_ids = boundary_data.popolo_areas.map { |a| a[:associated_wikidata_positions] }.flatten.to_set

%w[legislative executive].each do |political_entity_kind|
  political_entity_kind_dir = root_dir.join(political_entity_kind)
  index_file = political_entity_kind_dir.join('index.json')

  JSON.parse(index_file.read, symbolize_names: true).each do |political_entity_h|
    branch = Branch.for(political_entity_kind, political_entity_h)
    branch.terms.each do |term|
      output_dir = political_entity_kind_dir.join(term.output_relative)
      output_dir.mkpath
      output_pathname = output_dir.join('popolo-m17n.json')
      raw_results_pathname = output_dir.join('query-results.json')

      if actions.include? 'update'
        sparql_query = term.query(LANGUAGE_MAP)
        output_dir.join('query-used.rq').write(sparql_query)

        query_params = {
          query: sparql_query,
          format: 'json',
        }
        result = RestClient.get(URL, params: query_params)

        raw_results_pathname.write(result)
      end

      next unless actions.include?('build')
      data = JSON.parse(raw_results_pathname.read, symbolize_names: true)

      membership_rows = data[:results][:bindings].map do |row|
        WikidataRow.new(row, LANGUAGE_MAP)
      end

      persons = membership_rows.map do |membership|
        {
          name: membership.name_object('name'),
          id: membership[:item].value,
          identifiers: [
            {
              scheme: 'wikidata',
              identifier: membership[:item].value,
            },
          ],
          links: [
            {
              note: 'facebook',
              url: membership[:facebook]&.value&.prepend('https://www.facebook.com/'),
            },
          ].select { |o| o[:url] },
        }
      end.uniq.sort_by { |p| p[:id] }

      party_organizations = membership_rows.select do |membership|
        membership[:party]
      end.map do |membership|
        {
          name: membership.name_object('party_name'),
          id: membership[:party].value,
          classification: 'party',
          identifiers: [
            {
              scheme: 'wikidata',
              identifier: membership[:party].value,
            },
          ],
        }
      end.uniq.sort_by { |o| o[:id] }

      entity_organizations = membership_rows.map do |membership|
        {
          name: membership.name_object('org'),
          id: membership[:org].value,
          classification: 'branch',
          identifiers: [
            {
              scheme: 'wikidata',
              identifier: membership[:org].value,
            },
          ],
          area_id: membership[:org_jurisdiction]&.value,
        }.tap do |o|
          if political_entity_kind == 'legislative'
            seat_count = membership[:org_seat_count].value
            if seat_count.to_s.empty?
              puts "WARNING: no seat count found for the legislature #{wikidata_labels.item_with_label(membership[:org].value)}"
            end
            o['seat_counts'] = {membership[:role].value => seat_count}
          end
        end
      end.uniq.sort_by { |o| o[:id] }

      missing_jurisdictions = entity_organizations.reject { |o| o[:area_id] }
      missing_jurisdictions.each do |o|
        puts "ERROR: no P1001 (applies to jurisdiction) on #{political_entity_kind} #{wikidata_labels.item_with_label(o[:id])}"
      end
      exit(1) unless missing_jurisdictions.empty?

      # We should have all the relevant areas from the boundary data...
      related_positions = branch.positions_item_ids
      areas = boundary_data.popolo_areas.reject do |a|
        (a[:associated_wikidata_positions] & related_positions).empty?
      end
      # All position_item_ids should be referenced somewhere in the boundary data
      related_positions.each do |position_item_id|
        unless boundary_position_ids.include? position_item_id
          puts "WARNING: Position #{wikidata_labels.item_with_label(position_item_id)} not in boundary associated_wikidata_positions"
        end
      end
      known_areas = Set.new(areas.map { |a| a[:id] })
      # Make sure that all their parents are included:
      all_parents = areas.flat_map { |a| boundary_data.all_parents(a[:id]) }
      all_parents.each do |parent_area|
        next if known_areas.include? parent_area[:id]
        areas.push parent_area
        known_areas.add(parent_area[:id])
      end
      areas = areas.uniq.sort_by { |a| a[:id] }
      # Warn about any districts found from Wikidata that aren't in
      # in our boundary data:
      membership_rows.select { |m| m[:district] }.map do |m|
        area_wikidata_id = m[:district].value
        unless known_areas.include?(area_wikidata_id)
          puts "WARNING: the district #{wikidata_labels.item_with_label(area_wikidata_id)} wasn't found in the boundary data for position #{wikidata_labels.item_with_label(m[:role]&.value)}"
        end
      end

      # Check that none of these have a null person_id - we should only
      # allow that for the whole-country area.
      areas_with_bad_parents = areas.select do |area|
        area[:parent_id].nil? && !area[:id] == COUNTRY_WIKIDATA_ID
      end
      unless areas_with_bad_parents.empty?
        areas_with_bad_parents.each do |area|
          puts "Error: no parent area found for: #{area[:id]}"
        end
        raise 'Some areas has a null parent_id'
      end

      memberships = membership_rows.map do |membership|
        {
          id: membership[:statement].value,
          person_id: membership[:item].value,
          on_behalf_of_id: membership[:party]&.value,
          organization_id: membership[:org].value,
          area_id: membership[:district]&.value,
          start_date: membership[:start]&.value,
          end_date: membership[:end]&.value,
          role_superclass_code: membership[:role_superclass]&.value,
          role_superclass: membership[:role_superclass] && membership.name_object('role_superclass'),
          role_code: membership[:role].value,
          role: membership.name_object('role'),
        }.reject { |_, v| v.to_s.empty? }
        # The id here is the statement UUID, so you would have thought
        # that was enough to predictably order these, However, the
        # on_behalf_of_id might be from a P102 on the *person* so we
        # need to add that too.
      end.uniq.sort_by { |m| [m[:id], m[:on_behalf_of_id]] }

      all_data = {
        persons: persons,
        organizations: entity_organizations + party_organizations,
        areas: areas,
        memberships: memberships,
      }

      output_pathname.write(JSON.pretty_generate(all_data) + "\n")
    end
  end
end
