#!/usr/bin/env ruby

# frozen_string_literal: true

require 'bundler/setup'
require 'json'
require 'commons/builder'
require 'rest-client'

config = Config.new('config.json')

root_dir = Pathname.new('').dirname

valid_actions = %w[update build]

unknown_args = Set.new(ARGV) - Set.new(valid_actions)
unless unknown_args.empty?
  STDERR.puts "Usage: #{$PROGRAM_NAME} update|build"
  exit(1)
end

actions = if ARGV.empty?
            valid_actions.clone
          else
            ARGV.clone
          end

wikidata_labels = WikidataLabels.new(config.languages)

boundaries_dir = Dir.exist?('boundaries/build') ? 'boundaries/build' : 'boundaries'
boundaries_dir_pn = Pathname.new(boundaries_dir)
boundary_data = BoundaryData.new(wikidata_labels, boundaries_dir: boundaries_dir)
boundary_positions_pn = boundaries_dir_pn.join('position-data-query-results.json')

if actions.include? 'update'
  query = Query.new(
    sparql_query: WikidataQueries.new(config.languages).query_information_from_positions(
      boundary_data.all_positions, config.country_wikidata_id
    ),
    output_dir_pn: boundaries_dir_pn,
    output_fname_prefix: 'position-data-'
  )
  query.run
end

if actions.include? 'build'
  wd_rows = JSON.parse(boundary_positions_pn.read, symbolize_names: true)[:results][:bindings].map do |row|
    WikidataRow.new(row, config.languages)
  end
  position_data = wd_rows.map do |wd_row|
    {
      role_id: wd_row[:position].value,
      role_name: wd_row.name_object('position_name'),
      generic_role_id: wd_row[:positionSuperclass].value,
      generic_role_name: wd_row.name_object('position_superclass'),
      role_level: wd_row[:adminAreaType].value,
      role_type: wd_row[:positionType]&.value,
      organization_id: wd_row[:legislature].value,
      organization_name: wd_row.name_object('legislature'),
    }
  end
  # There might be multiple generic_roles (e.g. President of Brazil is
  # sublassed both from 'head of government' and 'president') but we
  # don't need both. Sort predictably but arbitrarily and pick the
  # first of those:
  deduplicated = position_data.group_by { |e| e[:role_id] }.values.map do |roles|
    roles.sort_by { |r| r[:generic_role_id] }[0]
  end
  # Now write it to disk:
  boundaries_dir_pn.join('position-data.json').write(
    JSON.pretty_generate(deduplicated) + "\n"
  )
end

boundary_position_ids = boundary_data.popolo_areas.map { |a| a[:associated_wikidata_positions] }.flatten.to_set

%w[legislative executive].each do |political_entity_kind|
  political_entity_kind_dir = root_dir.join(political_entity_kind)
  index_file = political_entity_kind_dir.join('index.json')

  JSON.parse(index_file.read, symbolize_names: true).each do |political_entity_h|
    branch = Branch.for(political_entity_kind, political_entity_h)
    branch.terms.each do |term|
      output_dir = political_entity_kind_dir.join(term.output_relative)
      output_dir.mkpath
      output_pathname = output_dir.join('popolo-m17n.json')
      query = Query.new(
        sparql_query: term.query(config.languages),
        output_dir_pn: output_dir
      )

      if actions.include? 'update'
        query.run
      end

      next unless actions.include?('build')
      data = query.last_saved_results

      membership_rows = data[:results][:bindings].map do |row|
        WikidataRow.new(row, config.languages)
      end

      membership_data = MembershipData.new(membership_rows, config.languages, political_entity_kind)

      missing_jurisdictions = membership_data.entity_organizations.reject { |o| o[:area_id] }
      missing_jurisdictions.each do |o|
        puts 'ERROR: no P1001 (applies to jurisdiction) on %<kind>s %<organization>s' %
             { kind: political_entity_kind, organization: wikidata_labels.item_with_label(o[:id]) }
      end
      exit(1) unless missing_jurisdictions.empty?

      # We should have all the relevant areas from the boundary data...
      related_positions = branch.positions_item_ids
      areas = boundary_data.popolo_areas.reject do |a|
        (a[:associated_wikidata_positions] & related_positions).empty?
      end
      # All position_item_ids should be referenced somewhere in the boundary data
      related_positions.each do |position_item_id|
        unless boundary_position_ids.include? position_item_id
          puts 'WARNING: Position %<position>s not in boundary associated_wikidata_positions' %
               { position: wikidata_labels.item_with_label(position_item_id) }
        end
      end
      known_areas = Set.new(areas.map { |a| a[:id] })
      # Make sure that all their parents are included:
      all_parents = areas.flat_map { |a| boundary_data.all_parents(a[:id]) }
      all_parents.each do |parent_area|
        next if known_areas.include? parent_area[:id]
        areas.push parent_area
        known_areas.add(parent_area[:id])
      end
      areas = areas.uniq.sort_by { |a| a[:id] }
      # Warn about any districts found from Wikidata that aren't in
      # in our boundary data:
      membership_rows.select { |m| m[:district] }.map do |m|
        area_wikidata_id = m[:district].value
        next if known_areas.include?(area_wikidata_id)
        puts "WARNING: the district %<district>s wasn't found in the boundary data for position %<position>s" %
             { district: wikidata_labels.item_with_label(area_wikidata_id),
               position: wikidata_labels.item_with_label(m[:role]&.value), }
      end

      # Check that none of these have a null person_id - we should only
      # allow that for the whole-country area.
      areas_with_bad_parents = areas.select do |area|
        area[:parent_id].nil? && !area[:id] == config.country_wikidata_id
      end
      unless areas_with_bad_parents.empty?
        areas_with_bad_parents.each do |area|
          puts "Error: no parent area found for: #{area[:id]}"
        end
        raise 'Some areas has a null parent_id'
      end

      all_data = {
        persons: membership_data.persons,
        organizations: membership_data.entity_organizations + membership_data.party_organizations,
        areas: areas,
        memberships: membership_data.memberships,
      }

      output_pathname.write(JSON.pretty_generate(all_data) + "\n")
    end
  end
end
