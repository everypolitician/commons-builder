#!/usr/bin/env ruby

# frozen_string_literal: true

require 'bundler/setup'
require 'json'
require 'commons/builder'
require 'rest-client'

URL = 'https://query.wikidata.org/sparql'

config = Config.new_from_file('config.json')

root_dir = Pathname.new('').dirname

valid_actions = %w[constituencies update build]

unknown_args = Set.new(ARGV) - Set.new(valid_actions)
unless unknown_args.empty?
  STDERR.puts "Usage: #{$PROGRAM_NAME} constituencies|update|build"
  exit(1)
end

actions = if ARGV.empty?
            valid_actions.clone
          else
            ARGV.clone
          end

wikidata_labels = WikidataLabels.new(config)

boundaries_dir = Dir.exist?('boundaries/build') ? 'boundaries/build' : 'boundaries'
boundary_data = BoundaryData.new(wikidata_labels, boundaries_dir: boundaries_dir)

boundary_position_ids = boundary_data.popolo_areas.map { |a| a[:associated_wikidata_positions] }.flatten.to_set

%w[legislative executive].each do |political_entity_kind|
  political_entity_kind_dir = root_dir.join(political_entity_kind)
  index_file = political_entity_kind_dir.join('index.json')

  branches = JSON.parse(index_file.read, symbolize_names: true).map do |political_entity_h|
    Branch.for(political_entity_kind, political_entity_h)
  end
  branches_by_id = branches.group_by(&:item_id)

  branch_type = Branch.branch_types[political_entity_kind]

  if actions.include?('constituencies') && branch_type.respond_to?(:constituencies)
    index_entries = []

    areas = branch_type.constituencies(config, branches)
    areas = areas.group_by { |area| [area[:legislature_jurisdiction_type].value, area[:is_lower_house].value] }
    areas.each do |(type_id, is_lower_house), areas|
      puts "Area type: #{type_id}, Lower house?: #{is_lower_house}, Numer of areas: #{areas.length}"
      areas_by_legislature = areas.group_by { |area| area[:legislature].value }
      boundary_names = {
        ['Q6256', false] => 'senate-constituencies',
        ['Q6256', true] => 'chamber-constituencies',
        ['Q590080', false] => 'regional-constituencies',
      }
      boundary_name = boundary_names.fetch [type_id, is_lower_house]
      full_boundary_dir_name = Pathname(boundaries_dir).join(boundary_name)
      Dir.mkdir(full_boundary_dir_name) unless Dir.exist?(full_boundary_dir_name)

      CSV.open(full_boundary_dir_name.join(boundary_name + '.csv'), "wb") do |boundary_csv|

        boundary_csv << [
          'WIKIDATA',
          'LEGIS_ID',
        ] + config.languages.map { |lang| "name_#{lang}" }


        areas_by_legislature.each do |legislature, areas|
          index_entry = {
            directory: boundary_name,
            area_type_wikidata_item_id: type_id,
            associations: [
              {
                comment: wikidata_labels.label_for(branches_by_id[legislature][0].position_item_id),
                position_item_id: branches_by_id[legislature][0].position_item_id,
              },
            ],
            #name_columns: config.languages.map { |lang| ["lang:#{lang}", "name_#{lang}"] }.to_h,
            name_columns: {
                "lang:es": "NOM"
            }
          }
          if areas_by_legislature.length > 1
            index_entry[:filter] = {
              match: legislature,
              #column: 'LEGIS_ID',
              column: 'MS_FB_PARE',
            }
          end
          areas.each do |area|
            boundary_csv << [
              area[:constituency].value,
              area[:legislature].value,
            ] + config.languages.map { |lang| area[:"constituency_name_#{lang}"]&.value }
          end
          #puts JSON.pretty_generate index_entry
          index_entries.push index_entry
        end
      end
    end

    Pathname.new('boundaries/build/index-new.json').open('wb').write(JSON.pretty_generate(index_entries))
  end

  branches.each do |branch|

    branch.terms.each do |term|
      output_dir = political_entity_kind_dir.join(term.output_relative)
      output_dir.mkpath
      output_pathname = output_dir.join('popolo-m17n.json')
      raw_results_pathname = output_dir.join('query-results.json')

      if actions.include? 'update'
        sparql_query = term.query(config)
        output_dir.join('query-used.rq').write(sparql_query)

        query_params = {
          query: sparql_query,
          format: 'json',
        }
        result = RestClient.get(URL, params: query_params)

        raw_results_pathname.write(result)
      end

      next unless actions.include?('build')
      data = JSON.parse(raw_results_pathname.read, symbolize_names: true)

      membership_rows = data[:results][:bindings].map do |row|
        WikidataRow.new(row, config.languages)
      end

      membership_data = MembershipData.new(membership_rows, config.languages, political_entity_kind)

      missing_jurisdictions = membership_data.entity_organizations.reject { |o| o[:area_id] }
      missing_jurisdictions.each do |o|
        puts 'ERROR: no P1001 (applies to jurisdiction) on %<kind>s %<organization>s' %
             { kind: political_entity_kind, organization: wikidata_labels.item_with_label(o[:id]) }
      end
      exit(1) unless missing_jurisdictions.empty?

      # We should have all the relevant areas from the boundary data...
      related_positions = branch.positions_item_ids
      areas = boundary_data.popolo_areas.reject do |a|
        (a[:associated_wikidata_positions] & related_positions).empty?
      end
      # All position_item_ids should be referenced somewhere in the boundary data
      related_positions.each do |position_item_id|
        unless boundary_position_ids.include? position_item_id
          puts 'WARNING: Position %<position>s not in boundary associated_wikidata_positions' %
               { position: wikidata_labels.item_with_label(position_item_id) }
        end
      end
      known_areas = Set.new(areas.map { |a| a[:id] })
      # Make sure that all their parents are included:
      all_parents = areas.flat_map { |a| boundary_data.all_parents(a[:id]) }
      all_parents.each do |parent_area|
        next if known_areas.include? parent_area[:id]
        areas.push parent_area
        known_areas.add(parent_area[:id])
      end
      areas = areas.uniq.sort_by { |a| a[:id] }
      # Warn about any districts found from Wikidata that aren't in
      # in our boundary data:
      membership_rows.select { |m| m[:district] }.map do |m|
        area_wikidata_id = m[:district].value
        next if known_areas.include?(area_wikidata_id)
        puts "WARNING: the district %<district>s wasn't found in the boundary data for position %<position>s" %
             { district: wikidata_labels.item_with_label(area_wikidata_id),
               position: wikidata_labels.item_with_label(m[:role]&.value), }
      end

      # Check that none of these have a null person_id - we should only
      # allow that for the whole-country area.
      areas_with_bad_parents = areas.select do |area|
        area[:parent_id].nil? && !area[:id] == config.country_wikidata_id
      end
      unless areas_with_bad_parents.empty?
        areas_with_bad_parents.each do |area|
          puts "Error: no parent area found for: #{area[:id]}"
        end
        raise 'Some areas has a null parent_id'
      end

      all_data = {
        persons: membership_data.persons,
        organizations: membership_data.entity_organizations + membership_data.party_organizations,
        areas: areas,
        memberships: membership_data.memberships,
      }

      output_pathname.write(JSON.pretty_generate(all_data) + "\n")
    end
  end
end
