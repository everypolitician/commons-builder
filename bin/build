#!/usr/bin/env ruby

# frozen_string_literal: true

require 'bundler/setup'
require 'json'
require 'commons/builder'
require 'rest-client'
require 'commons/integrity'

URL = 'https://query.wikidata.org/sparql'

config = Config.new_from_file('config.json')

root_dir = Pathname.new('').dirname

valid_actions = %w[update build check]

unknown_args = Set.new(ARGV) - Set.new(valid_actions)
unless unknown_args.empty?
  STDERR.puts "Usage: #{$PROGRAM_NAME} update|build"
  exit(1)
end

actions = if ARGV.empty?
            valid_actions.clone
          else
            ARGV.clone
          end

wikidata_client = WikidataClient.new
wikidata_labels = WikidataLabels.new(config: config, wikidata_client: wikidata_client)

boundaries_dir = Dir.exist?('boundaries/build') ? 'boundaries/build' : 'boundaries'
boundary_data = BoundaryData.new(wikidata_labels, boundaries_dir: boundaries_dir)

boundary_position_ids = boundary_data.popolo_areas.map { |a| a[:associated_wikidata_positions] }.flatten.to_set

%w[legislative executive].each do |political_entity_kind|
  political_entity_kind_dir = root_dir.join(political_entity_kind)
  index_file = political_entity_kind_dir.join('index.json')

  JSON.parse(index_file.read, symbolize_names: true).each do |political_entity_h|
    branch = Branch.for(political_entity_kind, political_entity_h)
    branch.terms.each do |term|
      output_dir = political_entity_kind_dir.join(term.output_relative)
      output_dir.mkpath
      output_pathname = output_dir.join('popolo-m17n.json')
      raw_results_pathname = output_dir.join('query-results.json')

      if actions.include? 'update'
        sparql_query = term.query(config)
        output_dir.join('query-used.rq').write(sparql_query)

        query_params = {
          query: sparql_query,
          format: 'json',
        }
        result = RestClient.get(URL, params: query_params)

        raw_results_pathname.write(result)
      end

      next unless actions.include?('build')
      data = JSON.parse(raw_results_pathname.read, symbolize_names: true)

      membership_rows = data[:results][:bindings].map do |row|
        WikidataRow.new(row, config.languages)
      end

      membership_data = MembershipData.new(membership_rows, config.languages, political_entity_kind)

      missing_jurisdictions = membership_data.entity_organizations.reject { |o| o[:area_id] }
      missing_jurisdictions.each do |o|
        puts 'ERROR: no P1001 (applies to jurisdiction) on %<kind>s %<organization>s' %
             { kind: political_entity_kind, organization: wikidata_labels.item_with_label(o[:id]) }
      end
      exit(1) unless missing_jurisdictions.empty?

      # We should have all the relevant areas from the boundary data...
      related_positions = branch.positions_item_ids
      areas = boundary_data.popolo_areas.reject do |a|
        (a[:associated_wikidata_positions] & related_positions).empty?
      end
      # All position_item_ids should be referenced somewhere in the boundary data
      related_positions.each do |position_item_id|
        unless boundary_position_ids.include? position_item_id
          puts 'WARNING: Position %<position>s not in boundary associated_wikidata_positions' %
               { position: wikidata_labels.item_with_label(position_item_id) }
        end
      end
      known_areas = Set.new(areas.map { |a| a[:id] })
      # Make sure that all their parents are included:
      all_parents = areas.flat_map { |a| boundary_data.all_parents(a[:id]) }
      all_parents.each do |parent_area|
        next if known_areas.include? parent_area[:id]
        areas.push parent_area
        known_areas.add(parent_area[:id])
      end
      areas = areas.uniq.sort_by { |a| a[:id] }
      # Warn about any districts found from Wikidata that aren't in
      # in our boundary data:
      membership_rows.select { |m| m[:district] }.map do |m|
        area_wikidata_id = m[:district].value
        next if known_areas.include?(area_wikidata_id)
        puts "WARNING: the district %<district>s wasn't found in the boundary data for position %<position>s" %
             { district: wikidata_labels.item_with_label(area_wikidata_id),
               position: wikidata_labels.item_with_label(m[:role]&.value), }
      end

      # Check that none of these have a null person_id - we should only
      # allow that for the whole-country area.
      areas_with_bad_parents = areas.select do |area|
        area[:parent_id].nil? && !area[:id] == config.country_wikidata_id
      end
      unless areas_with_bad_parents.empty?
        areas_with_bad_parents.each do |area|
          puts "Error: no parent area found for: #{area[:id]}"
        end
        raise 'Some areas has a null parent_id'
      end

      all_data = {
        persons: membership_data.persons,
        organizations: membership_data.entity_organizations + membership_data.party_organizations,
        areas: areas,
        memberships: membership_data.memberships,
      }

      output_pathname.write(JSON.pretty_generate(all_data) + "\n")
    end
  end
end

def config_pathname
  in_gem_config = Pathname.new(__dir__).join('..', 'integrity-config.yml')
  current_dir_config = Pathname.new('.integrity-config.yml')
  return current_dir_config if current_dir_config.exist?
  in_gem_config
end

if actions.include?('check')
  files = Pathname.glob(root_dir + '**/*')
  config = Commons::Integrity::Config.new(config_pathname)
  errors = files.flat_map do |file|
    Commons::Integrity::Report.new(file: file, config: config).errors
  end
  unless errors.empty?
    puts 'Integrity checks failed:'
    puts errors
    exit(1)
  end
end
